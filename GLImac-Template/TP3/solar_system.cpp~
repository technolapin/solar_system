
// the order is important
#include "globject.hpp"
#include "instance.hpp"
#include "textures_handler.hpp"


#include "glvars.hpp"
#include "program_holder.hpp"
#include "renderable.hpp"


#include "scene.cpp"
#include "program_holder.cpp"



GLObject
make_sphere(GLfloat radius,
            GLsizei discLat,
            GLsizei discLong)
{
   std::cout << "POLO 1!" << std::endl;

    std::vector<ShapeVertex> sphere;

    auto sph_obj = Sphere(radius, discLat, discLong);
    auto n = sph_obj.getVertexCount();
    auto ptr = sph_obj.getDataPointer();
    std::cout << "POLO 1.5!" << std::endl;
    for (auto i = 0; i < n; ++i)
    {
       sphere.push_back(ptr[i]);
    }
    std::cout << "POLO 2!" << std::endl;
    return GLObject(sphere);
}





int main(int argc, char** argv) {
    // Initialize SDL and open a window
    SDLWindowManager windowManager(400, 400, "GLImac");

    // Initialize glew for OpenGL3+ support
    GLenum glewInitError = glewInit();
    if(GLEW_OK != glewInitError) {
        std::cerr << glewGetErrorString(glewInitError) << std::endl;
        return EXIT_FAILURE;
    }

    std::cout << "OpenGL Version : " << glGetString(GL_VERSION) << std::endl;
    std::cout << "GLEW Version : " << glewGetString(GLEW_VERSION) << std::endl;

    /*********************************
     * HERE SHOULD COME THE INITIALIZATION CODE
     *********************************/
    
    FilePath applicationPath(argv[0]);
    auto path_vs = applicationPath.dirPath() + "shaders" + argv[1];
    auto path_fs = applicationPath.dirPath() + "shaders" + argv[2];
    auto program = loadProgram(path_vs, path_fs);    
    program.use();
    
    TextureHandler textures(
       applicationPath.dirPath()
       + ".."
       + ".."
       + "GLImac-Template"
       + "assets"
       + "textures"
       );
    
    auto earth_tex = textures.load("EarthMap.jpg");
    auto moon_tex = textures.load("MoonMap.jpg");
    
    GLuint uTexture = glGetUniformLocation(program.getGLId(), "uTexture");

    ProgramHolder pgrm1 = ProgramHolder(path_vs, path_fs);
    pgrm1.add_uniform(GLType::Sampler2D, "uTexture");

    std::vector<std::shared_ptr<ProgramHolder>> programs;

    programs.push_back(std::make_shared<ProgramHolder>(pgrm1));

    auto single_texture = RenderableBuilder(programs[0])
       .with(GLType::Sampler2D, earth_tex)
       .build();
       

    
    GLuint uMVP = glGetUniformLocation(program.getGLId(), "uMVPMatrix");
    GLuint uMV = glGetUniformLocation(program.getGLId(), "uMVMatrix");
    GLuint uNormal = glGetUniformLocation(program.getGLId(), "uNormalMatrix");

    auto M = glm::translate(glm::mat4(), glm::vec3(0.0f, 0.0f, -5.0f));
    auto V = glm::mat4(1.0f);
    auto P = glm::perspective(
       glm::radians(70.f),
       1.0f,
       0.1f,
       100.0f
       );

    auto MV = V*M;
    auto MVP = P*MV;

    auto N = MV;
    std::cout << "MARCO 0!" << std::endl;
    glUniformMatrix4fv(uMVP,
                       1, false,
                       glm::value_ptr(MVP));
    glUniformMatrix4fv(uMV,
                       1, false,
                       glm::value_ptr(MV));
    glUniformMatrix4fv(uNormal,
                       1, false,
                       glm::value_ptr(N));

    std::cout << "MARCO 1!" << std::endl;

    
   
    std::vector<GLObject> meshes;
    meshes.push_back(make_sphere(1.0, 30, 30));
    
    

    glEnable(GL_DEPTH_TEST);
    
    std::cout << "MARCO 2!" << std::endl;

    for (auto & obj: meshes)
    {
       std::cout << obj << std::endl;
    }



    std::vector<glm::vec3> axes;
    std::vector<glm::vec3> pos_init;

    for(int i = 0; i < 32; ++i)
    {
       auto axe = glm::sphericalRand(1.0f);
       axes.push_back(axe);
       auto p = glm::sphericalRand(1.0f);
       auto p_ortho = glm::normalize(p - glm::dot(p, axe)*axe);
       
       pos_init.push_back(p_ortho);
    }

//    GLRenderable earth_object = {meshes[0], single_texture};
    
    // Application loop:
    bool done = false;
    while(!done) {
        // Event loop:
        SDL_Event e;
        while(windowManager.pollEvent(e)) {
            if(e.type == SDL_QUIT) {
                done = true; // Leave the loop after this iteration
            }
        }

        // *********************************
        // * HERE SHOULD COME THE RENDERING CODE
        // *********************************


        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        Scene scene;
        {
           auto center = glm::translate(glm::mat4(), glm::vec3(0.0f, 0.0f, -5.0f));
    
           Instance planet_inst = {center};
           scene.add(meshes[0], single_texture, planet_inst);

           for (auto i = 0; i < axes.size(); ++i)
           {
              auto rot_vec = axes[i];
              auto pos0 = pos_init[i];
              pos0 = glm::vec3(2.0*pos0[0], 2.0*pos0[1], 2.0*pos0[2]);
              glm::mat4 moon_mat = glm::translate(glm::mat4(1), glm::vec3(0, 0, -5));
              moon_mat = glm::rotate(moon_mat, windowManager.getTime(), rot_vec);
              moon_mat = glm::translate(moon_mat, pos0);
              moon_mat = glm::scale(moon_mat, glm::vec3(0.2, 0.2, 0.2));
              Instance moon = {moon_mat};
    

              scene.add(meshes[0], single_texture, moon);
           }
        }
        scene.render(uMVP, uMV, uNormal, V, P);


        
        // Update the display
        windowManager.swapBuffers();
    }

    for (auto & obj: meshes)
    {
       obj.free_gpu();
    }
       
    return EXIT_SUCCESS;
}
